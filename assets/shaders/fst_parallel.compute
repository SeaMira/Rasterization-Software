#version 430

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba8, binding = 0) uniform image2D outputImage;

struct Sphere 
{
    vec4 positionr;  // (x, y, z, r)
};

layout(std430, binding = 1) buffer SphereBuffer 
{
    Sphere spheres[];
};

layout(std430, binding = 2) buffer DepthBuffer 
{
    int depthData[];
};

uniform mat4 view;
uniform mat4 proj;

uniform vec3 front;
uniform vec3 up;
// uniform vec3 right;
uniform vec3 cameraPos;

uniform ivec2 screenResolution;

uniform float fov;
uniform float aspectRatio;
uniform int sphereCount;

vec3 lightColor = vec3(0.01, 1.0, 0.05);
float diffuseI = 0.9;

struct bboxCorners
{
    // view space
    vec3 upRightCorner;
    vec3 upLeftCorner;
    vec3 downRightCorner;
    vec3 downLeftCorner;

    // screen space
    vec2 minCorner;
    vec2 maxCorner;
};

uint vecToColor(vec3 lambertCos) {
    uint R = uint(lambertCos.r * 255.0);
    uint G = uint(lambertCos.g * 255.0);
    uint B = uint(lambertCos.b * 255.0);
    return (R << 0) | (G << 8) | (B << 16) | (0xFF << 24);
}

float iSphere(vec3 ro, vec3 rd, vec3 sph, float radius )
{
    float a = dot(rd, rd);
    float b = dot( rd, sph );
    float c = dot( sph, sph ) - radius*radius;
    float h = b*b - a * c;
    if( h < 0.0f) return -1.0f;
    return (b - sqrt( h ))/a;
}

bboxCorners getSphereBbox(const vec3 cameraSpaceSphere, const vec3 camImposPos, 
    const vec3 normCamSpaceSphere, const float sphRadius)
{
    const float sinAngle = sphRadius / (length(cameraSpaceSphere) + 1e-6f);
    const float tanAngle = tan(asin(sinAngle));
    const float quadScale = tanAngle * length(camImposPos);

    vec3 impU = normalize(cross(normCamSpaceSphere, up));
    vec3 impV = cross(impU, normCamSpaceSphere) * quadScale;
    impU *= quadScale;

    const vec3 upRightCorner = camImposPos + impU + impV;
    const vec3 upLeftCorner = camImposPos - impU + impV;
    const vec3 downRightCorner = camImposPos + impU - impV;
    const vec3 downLeftCorner = camImposPos - impU - impV;

    const vec4 upRight = proj * vec4(upRightCorner, 1.0f);
    const vec4 upLeft = proj * vec4(upLeftCorner, 1.0f);
    const vec4 downRight = proj * vec4(downRightCorner, 1.0f);
    const vec4 downLeft = proj * vec4(downLeftCorner, 1.0f);
    
    const vec3 ndcUpRight = vec3(upRightCorner) / upRight.w;
    const vec3 ndcUpLeft = vec3(upLeftCorner) / upLeft.w;
    const vec3 ndcDownRight = vec3(downRightCorner) / downRight.w;
    const vec3 ndcDownLeft = vec3(downLeftCorner) / downLeft.w;

    vec2 minCorner = min(min(ndcUpRight.xy, ndcUpLeft.xy), min(ndcDownRight.xy, ndcDownLeft.xy));
    vec2 maxCorner = max(max(ndcUpRight.xy, ndcUpLeft.xy), max(ndcDownRight.xy, ndcDownLeft.xy));


    return bboxCorners(upRightCorner, upLeftCorner, downRightCorner, downLeftCorner, minCorner, maxCorner); 
}

void drawSphere(Sphere sphere)
{
    vec3 cameraSpaceSphere = vec3(view * vec4(sphere.positionr.xyz, 1.0f));
    vec3 normCamSpaceSphere = normalize(cameraSpaceSphere);
    vec3 camImposPos = cameraSpaceSphere - normCamSpaceSphere * sphere.positionr.w;

    bboxCorners sphereBbox = getSphereBbox(cameraSpaceSphere, camImposPos,
        normCamSpaceSphere, sphere.positionr.w);
    
    ivec2 screenMin, screenMax;

    screenMin.x = int(((sphereBbox.minCorner.x/aspectRatio) * 0.5f + 0.5f) * screenResolution.x);
    screenMin.y = int((sphereBbox.minCorner.y * 0.5f + 0.5f) * screenResolution.y);
    screenMax.x = int(((sphereBbox.maxCorner.x/aspectRatio) * 0.5f + 0.5f) * screenResolution.x);
    screenMax.y = int((sphereBbox.maxCorner.y * 0.5f + 0.5f) * screenResolution.y);

    if (dot(sphere.positionr.xyz - cameraPos, front) > 0.5f && 
        !((screenMin.x < 0 && screenMax.x > screenResolution.x) || 
        (screenMin.y < 0 && screenMax.y > screenResolution.y))) 
    {
        const float difx = screenMax.x - screenMin.x;
        const float dify = screenMax.y - screenMin.y;
        
        for (int px = max(0, screenMin.x); px < min(screenMax.x, screenResolution.x); px++)
        {
            for (int py = max(0, screenMin.y); py < min(screenResolution.y, screenMax.y); py++)
            {

                const float u = float(px - screenMin.x)/ difx;
                const float v = float(py - screenMin.y)/ dify;
                const vec3 A = mix(sphereBbox.upLeftCorner, sphereBbox.upRightCorner, u);
                const vec3 B = mix(sphereBbox.downLeftCorner, sphereBbox.downRightCorner, u);
                const vec3 viewImpPos = mix(A, B, v);
                const float h = iSphere(cameraPos, viewImpPos, cameraSpaceSphere, sphere.positionr.w);

                const bool showBbox = (px == screenMin.x || py == screenMin.y || px == screenMax.x - 1 || py == screenMax.y - 1);
                if ((h > 0.0f)) 
                {
                    const int index = (screenResolution.y - py - 1) * screenResolution.x + px;
                    const vec3 hit = viewImpPos * h;
                    const float depth = hit.z < 0.0f ? (hit.z * proj[2].z + proj[3].z) / -hit.z : 30000.0f;
                    const int idepth = floatBitsToInt(depth);
                    const int old = atomicMin(depthData[index], int(idepth));
                    const vec3 normal = normalize( hit - cameraSpaceSphere );
                    const float lambertCos = dot(normal, -normalize(hit));
                    if (old > idepth) continue;

                    imageStore(outputImage, ivec2(px, py), vec4(lambertCos * lightColor * diffuseI, 1.0));
                    
                }
            }
        }
    }
}


void main() 
{
    uint index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_WorkGroupSize.x;

    // Check if the index is out of bounds
    if (index >= sphereCount) {
        return;  // If index is greater that the amount of spheres, return
    }

    // Get sphere
    Sphere s = spheres[index];

    drawSphere(s);
}